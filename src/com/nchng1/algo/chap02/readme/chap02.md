# 1. 递归

**master公式：**

1. Master公式：**T(N) = a\*T(N/b) + O(N^d)**
2. 公式解释：n表示问题的规模，a表示递归的次数也就是生成的子问题数，N/b表示子问题的规模。O(N^d)表示除了递归操作以外其余操作的复杂度
3. 结论（证明省略）：
   ①当d<logb a时，时间复杂度为O(N^(logb a))
   ②当d=logb a时，时间复杂度为O((N^d)*logN)
   ③当d>logb a时，时间复杂度为O(N^d)  
4. **注意：子问题规模必须等分，不管你是分成几部分**



# 2. 归并排序

1. 使用递归排好两部分的顺序
2. 开辟一个辅助数组将两部分依次比较合并到一起
3. 时间复杂度为N*logN , 额外空间复杂度为 O(N)
4. 复杂度为N*logN的原因是 **没有像O(N^2)的排序方法一样浪费比较信息**



# 3. 小和问题、逆序对问题

- 数组中一个数的左边小和等价于它右边大于它的个数*它本身的值
- 统计数量的同时要排序
- 左右两侧的值相同时先归并右侧



# 4. 荷兰国旗问题

1. **问题一**：给定一个数num，把数组中小于等num的放数组左边，反之放右边。要求额外空间复杂度为O(1)，时间复杂度为O(N)
2. 问题一思路：
   - 初始化一个小于区域
   - 假如 [i] <= num,把 i 位置上的数和区域的下一个数交换，然后区域++
   - 假如 [i] > num,
   -  i++
3. **问题二**：在问题一的基础上，把等于num的放中间，小于num的放左边，大于num的放右边
4. 问题二思路：
   - 左右两边各自初始化一个区域，一个大于区域，一个小于区域
   - 假如 [i] > num, 把当前数和大于区域的前一个数交换，大于区域--
   - 假如 [i] < num, 把当前数和小于区域的下一个数交换，小于区域++
   - i++



# 5. 快速排序

1. 快速排序基础：荷兰国旗问题 + 递归
2. 版本：
   1. 快排1.0：
      - 选数组最后一个数为num
      - 分小于等于num区域 和 大于num区域，时间复杂度为O(N^2)
   2. 快排2.0：
      - 选数组最后一个数为num
      - 分小于num、等于num、大于num区域，除了等于区域都进入递归，时间复杂度为O(N^2)，但是比1.0版本快一丢丢
   3. 快排3.0：
      - 从数组中随机的选择一个数与最后一位的交换
      - 在最坏数据情况下，随机一个数与最后一个数交换的所有复杂度概率累加，求数据长期期望是 N*logN，所以3.0的时间复杂度为O(N * logN)
      - 其余不变

